{
  "documentAnalysis": {
    "metadata": {
      "title": "Keeping a widget up to date",
      "subtitle": "Plan your widget's timeline to show timely, relevant information using dynamic views, and update the timeline when things change.",
      "author": "Apple Inc.",
      "copyright": "Copyright © 2025 Apple Inc. All rights reserved.",
      "sourceUrl": "https://developer.apple.com/documentation/widgetkit/keeping-a-widget-up-to-date",
      "documentType": "technical",
      "articleType": "Article",
      "primaryLanguage": "English",
      "programmingLanguage": "Swift",
      "framework": "WidgetKit",
      "breadcrumb": [
        "Documentation",
        "WidgetKit",
        "Widgets and watch complications",
        "Keeping a widget up to date"
      ],
      "platforms": [
        "iOS",
        "iPadOS",
        "macOS",
        "tvOS",
        "visionOS",
        "watchOS"
      ],
      "keywords": [
        "WidgetKit",
        "Timeline",
        "TimelineProvider",
        "TimelineEntry",
        "WidgetCenter",
        "widget updates",
        "budget",
        "refresh policy",
        "Smart Stack",
        "relevance"
      ],
      "summary": "This Apple Developer documentation article explains how to keep widgets up to date using timelines, budget management, and WidgetCenter APIs. It covers predictable timeline generation, handling timeline changes, relevance information for Smart Stacks, and dynamic date displays."
    },
    "navigation": {
      "header": {
        "siteLogo": {
          "type": "icon",
          "description": "Apple logo (apple symbol)",
          "position": "top-left"
        },
        "siteName": "Developer",
        "mainNavigation": [
          {"text": "News", "type": "link"},
          {"text": "Discover", "type": "link"},
          {"text": "Design", "type": "link"},
          {"text": "Develop", "type": "link"},
          {"text": "Distribute", "type": "link"},
          {"text": "Support", "type": "link"},
          {"text": "Account", "type": "link"}
        ],
        "secondaryNavigation": {
          "label": "Documentation",
          "position": "below main nav"
        },
        "languageSelector": {
          "label": "Language:",
          "selectedValue": "Swift",
          "position": "top-right of content area"
        }
      },
      "leftSidebar": {
        "title": "WidgetKit",
        "filterInput": {
          "placeholder": "Filter /",
          "type": "search-field"
        },
        "navigationTree": [
          {
            "sectionTitle": "Keeping a widget up to date",
            "expanded": true,
            "items": [
              {"text": "Overview", "type": "link", "icon": "document-icon"},
              {"text": "TimelineProvider", "prefix": "Pr", "type": "protocol-link"},
              {"text": "AppIntentTimelineProvider", "prefix": "Pr", "type": "protocol-link"},
              {"text": "IntentTimelineProvider", "prefix": "Pr", "type": "protocol-link"},
              {"text": "TimelineProviderContext", "prefix": "S", "type": "struct-link"},
              {"text": "TimelineEntry", "prefix": "Pr", "type": "protocol-link"},
              {"text": "Timeline", "prefix": "S", "type": "struct-link"},
              {"text": "WidgetCenter", "prefix": "C", "type": "class-link"}
            ]
          },
          {
            "sectionTitle": "Push notification updates",
            "expanded": false,
            "items": [
              {"text": "Updating widgets with WidgetKit p...", "truncated": true, "fullText": "Updating widgets with WidgetKit push notifications", "type": "article-link"},
              {"text": "WidgetPushHandler", "prefix": "Pr", "type": "protocol-link"},
              {"text": "WidgetPushInfo", "prefix": "S", "type": "struct-link"}
            ]
          },
          {
            "sectionTitle": "Capabilities",
            "expanded": false,
            "items": [
              {"text": "Accessing location information in ...", "truncated": true, "fullText": "Accessing location information in widgets", "type": "article-link"},
              {"text": "Making network requests in a widg...", "truncated": true, "fullText": "Making network requests in a widget extension", "type": "article-link"}
            ]
          },
          {
            "sectionTitle": "Debugging",
            "expanded": false,
            "items": [
              {"text": "Previewing widgets and Live Activi...", "truncated": true, "fullText": "Previewing widgets and Live Activities", "type": "article-link"},
              {"text": "Preview macros", "type": "topic-link"}
            ]
          }
        ]
      },
      "rightSidebar": {
        "sections": [
          {
            "heading": "Tools",
            "items": [
              "Swift",
              "SwiftUI",
              "Swift Playground",
              "TestFlight",
              "Xcode",
              "Xcode Cloud",
              "SF Symbols"
            ]
          },
          {
            "heading": "Topics & Technologies",
            "items": [
              "Accessibility",
              "Accessories",
              "App Extension",
              "App Store",
              "Audio & Video",
              "Augmented Reality",
              "Design",
              "Distribution",
              "Education",
              "Fonts",
              "Games",
              "Health & Fitness",
              "In-App Purchase",
              "Localization",
              "Maps & Location",
              "Machine Learning & AI",
              "Open Source",
              "Security",
              "Safari & Web"
            ]
          },
          {
            "heading": "Resources",
            "items": [
              {"text": "Documentation", "type": "link"},
              {"text": "Tutorials", "type": "link"},
              {"text": "Downloads", "type": "link"},
              {"text": "Forums", "type": "link"},
              {"text": "Videos", "type": "link"}
            ]
          },
          {
            "heading": "Support",
            "items": [
              {"text": "Support Articles", "type": "link"},
              {"text": "Contact Us", "type": "link"},
              {"text": "Bug Reporting", "type": "link"},
              {"text": "System Status", "type": "link"}
            ]
          },
          {
            "heading": "Account",
            "items": [
              {"text": "Apple Developer", "type": "link"},
              {"text": "App Store Connect", "type": "link"},
              {"text": "Certificates, IDs, & Profiles", "type": "link"},
              {"text": "Feedback Assistant", "type": "link"}
            ]
          },
          {
            "heading": "Programs",
            "items": [
              {"text": "Apple Developer Program", "type": "link"},
              {"text": "Apple Developer Enterprise Program", "type": "link"},
              {"text": "App Store Small Business Program", "type": "link"},
              {"text": "MFi Program", "type": "link"},
              {"text": "News Partner Program", "type": "link"},
              {"text": "Video Partner Program", "type": "link"},
              {"text": "Security Bounty Program", "type": "link"},
              {"text": "Security Research Device Program", "type": "link"}
            ]
          },
          {
            "heading": "Events",
            "items": [
              {"text": "Meet with Apple", "type": "link"},
              {"text": "Apple Developer Centers", "type": "link"},
              {"text": "App Store Awards", "type": "link"},
              {"text": "Apple Design Awards", "type": "link"},
              {"text": "Apple Developer Academies", "type": "link"},
              {"text": "WWDC", "type": "link"}
            ]
          }
        ]
      },
      "footer": {
        "legalLinks": [
          {"text": "Terms of Use", "type": "link"},
          {"text": "Privacy Policy", "type": "link"},
          {"text": "Agreements and Guidelines", "type": "link"}
        ],
        "themeToggle": {
          "options": ["Light", "Dark", "Auto"],
          "type": "segmented-control"
        },
        "feedbackSection": {
          "text": "To submit feedback on documentation, visit Feedback Assistant.",
          "linkText": "Feedback Assistant",
          "type": "external-link"
        },
        "copyright": "Copyright © 2025 Apple Inc. All rights reserved."
      }
    },
    "pages": [
      {
        "pageNumber": 1,
        "layout": {
          "type": "three-column",
          "columns": 3,
          "leftSidebarWidth": "approximately 250px",
          "mainContentWidth": "flexible, center",
          "rightSidebarWidth": "approximately 200px",
          "description": "Left sidebar with navigation tree, main content area in center, right sidebar with tools/topics/resources"
        },
        "sections": [
          {
            "sectionId": "header",
            "elements": [
              {
                "elementId": "page-title",
                "elementType": "heading",
                "level": 1,
                "content": {
                  "text": "Keeping a widget up to date",
                  "verbatim": true
                }
              },
              {
                "elementId": "page-subtitle",
                "elementType": "paragraph",
                "content": {
                  "text": "Plan your widget's timeline to show timely, relevant information using dynamic views, and update the timeline when things change.",
                  "verbatim": true
                }
              }
            ]
          },
          {
            "sectionId": "overview",
            "sectionTitle": "Overview",
            "elements": [
              {
                "elementId": "overview-heading",
                "elementType": "heading",
                "level": 2,
                "content": {
                  "text": "Overview",
                  "verbatim": true
                }
              },
              {
                "elementId": "overview-para1",
                "elementType": "paragraph",
                "content": {
                  "text": "Widgets use SwiftUI views to display their content. WidgetKit renders the views on your behalf in a separate process. As a result, your widget extension is not continually active, even if the widget is onscreen. Despite your widget not always being active, there are several ways you can keep its content up to date:",
                  "verbatim": true
                }
              },
              {
                "elementId": "overview-list1",
                "elementType": "list",
                "listType": "unordered",
                "content": {
                  "items": [
                    "Create a timeline that updates your widget for for regular, predictable events.",
                    "Tell the system to reload all timelines when data changes; for example, when your app receives new data.",
                    "Use WidgetKit push notifications in addition to timelines to update your widget."
                  ],
                  "verbatim": true,
                  "note": "First item contains typo 'for for' in original document"
                }
              },
              {
                "elementId": "overview-para2",
                "elementType": "paragraph",
                "content": {
                  "text": "WidgetKit push notifications are an additional way to update your widget that doesn't replace timeline updates. For more information, refer to Updating widgets with WidgetKit push notifications.",
                  "verbatim": true,
                  "links": [
                    {
                      "text": "Updating widgets with WidgetKit push notifications",
                      "type": "internal-documentation-link"
                    }
                  ]
                }
              }
            ]
          },
          {
            "sectionId": "plan-reloads-within-budget",
            "sectionTitle": "Plan reloads within a budget",
            "elements": [
              {
                "elementId": "budget-heading",
                "elementType": "heading",
                "level": 2,
                "content": {
                  "text": "Plan reloads within a budget",
                  "verbatim": true
                }
              },
              {
                "elementId": "budget-para1",
                "elementType": "paragraph",
                "content": {
                  "text": "Reloading widgets consumes system resources and causes battery drain due to additional networking and processing. To reduce this performance impact and maintain all-day battery life, limit the frequency and number of updates you request to what's necessary.",
                  "verbatim": true
                }
              },
              {
                "elementId": "budget-para2",
                "elementType": "paragraph",
                "content": {
                  "text": "To manage system load, WidgetKit uses a budget to distribute widget reloads over the course of the day. The budget allocation is dynamic and takes many factors into account, including:",
                  "verbatim": true
                }
              },
              {
                "elementId": "budget-list1",
                "elementType": "list",
                "listType": "unordered",
                "content": {
                  "items": [
                    "The frequency and times the widget is visible to the user.",
                    "The widget's last reload time.",
                    "Whether the widget's containing app is active."
                  ],
                  "verbatim": true
                }
              },
              {
                "elementId": "budget-para3",
                "elementType": "paragraph",
                "content": {
                  "text": "WidgetKit maintains different budgets for each active widget the user adds to their device. For example, if the user adds two instances of a configurable sports widget, showing information for two different teams, each widget has its own budget.",
                  "verbatim": true
                }
              },
              {
                "elementId": "budget-para4",
                "elementType": "paragraph",
                "content": {
                  "text": "A widget's budget applies to a 24-hour period. WidgetKit tunes the 24-hour window to the user's daily usage pattern, which means the daily budget doesn't necessarily reset at exactly midnight. For a widget the user frequently views, a daily budget typically includes from 40 to 70 refreshes. This rate roughly translates to widget reloads every 15 to 60 minutes, but it's common for these intervals to vary due to the many factors involved.",
                  "verbatim": true
                }
              },
              {
                "elementId": "budget-note",
                "elementType": "annotation",
                "annotationType": "note",
                "content": {
                  "label": "Note",
                  "text": "The system takes a few days to learn the user's behavior. During this learning period, your widget may receive more reloads than normal.",
                  "verbatim": true
                }
              },
              {
                "elementId": "budget-para5",
                "elementType": "paragraph",
                "content": {
                  "text": "Cases in which WidgetKit doesn't count reloads against your widget's budget include when:",
                  "verbatim": true
                }
              },
              {
                "elementId": "budget-list2",
                "elementType": "list",
                "listType": "unordered",
                "content": {
                  "items": [
                    "The widget's containing app is in the foreground.",
                    "The widget's containing app has an active audio or navigation session.",
                    "The widget performs an app intent, such as when the user taps a button or toggles a switch.",
                    "The widget performs an animation.",
                    "The system locale changes.",
                    "Dynamic Type or Accessibility settings change."
                  ],
                  "verbatim": true
                }
              },
              {
                "elementId": "budget-para6",
                "elementType": "paragraph",
                "content": {
                  "text": "For cases such as system appearance changes or system locale changes, don't request a timeline reload from your app. The system updates your widgets automatically. In StandBy, the system refreshes your widget's display at a system-defined rate that doesn't count against the its budget.",
                  "verbatim": true,
                  "note": "Contains typo 'against the its budget' in original document"
                }
              },
              {
                "elementId": "budget-para7",
                "elementType": "paragraph",
                "content": {
                  "text": "Although your widget timeline provider drives your reload schedule, WidgetKit sometimes reloads your widget to help keep its content fresh. Some common scenarios include:",
                  "verbatim": true
                }
              },
              {
                "elementId": "budget-list3",
                "elementType": "list",
                "listType": "unordered",
                "content": {
                  "items": [
                    "If a widget is on a Home Screen page that the user rarely visits, WidgetKit may reduce the frequency of reloads for that widget. Later, when the user views the page, WidgetKit may reload the widget when it becomes visible.",
                    "For widgets that use Location Services, WidgetKit reloads them after a significant location change happens. For more information related to reloads for widgets that use Location Services, refer to Accessing location information in widgets."
                  ],
                  "verbatim": true,
                  "links": [
                    {
                      "text": "Accessing location information in widgets",
                      "type": "internal-documentation-link"
                    }
                  ]
                }
              },
              {
                "elementId": "budget-para8",
                "elementType": "paragraph",
                "content": {
                  "text": "If your widget can predict points in time that it should reload, the best approach is to generate a timeline for as many future dates as possible. Keep the interval of entries in the timeline as large as possible for the content you display. WidgetKit imposes a minimum amount of time before it reloads a widget. Your timeline provider should create timeline entries that are at least about 5 minutes apart. WidgetKit may coalesce reloads across multiple widgets, affecting the exact time a widget is reloaded.",
                  "verbatim": true
                }
              }
            ]
          },
          {
            "sectionId": "generate-timeline-for-predictable-events",
            "sectionTitle": "Generate a timeline for predictable events",
            "elements": [
              {
                "elementId": "predictable-heading",
                "elementType": "heading",
                "level": 2,
                "content": {
                  "text": "Generate a timeline for predictable events",
                  "verbatim": true
                }
              },
              {
                "elementId": "predictable-para1",
                "elementType": "paragraph",
                "content": {
                  "text": "Many widgets have predictable points in time where it makes sense to update their content. For example, a widget that displays weather information might update the temperature hourly throughout the day. A stock market widget could update its content frequently during open market hours, but not at all over the weekend. By planning these times in advance, WidgetKit automatically refreshes your widget when the appropriate time arrives.",
                  "verbatim": true
                }
              },
              {
                "elementId": "predictable-para2",
                "elementType": "paragraph",
                "content": {
                  "text": "When you define your widget, you implement a custom TimelineProvider. WidgetKit gets a timeline from your provider, and uses it to track when to update your widget. A timeline is an array of TimelineEntry objects. Each entry in the timeline has a date and time, and additional information the widget needs to display its view. In addition to the timeline entries, the timeline specifies a refresh policy that tells WidgetKit when to request a new timeline.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "TimelineProvider", "type": "protocol"},
                    {"text": "TimelineEntry", "type": "protocol"}
                  ]
                }
              },
              {
                "elementId": "predictable-para3",
                "elementType": "paragraph",
                "content": {
                  "text": "The following is an example of a game widget that displays a character's health level. When the health level is less then 100 percent, the character recovers at a rate of 25 percent per hour. For example, when the character's health level is 25 percent, it takes 3 hours to fully recover to 100 percent. The following diagram shows how WidgetKit requests the timeline from the provider, rendering the widget at each time specified in the timeline entries.",
                  "verbatim": true,
                  "note": "Contains 'less then' which may be typo for 'less than' in original"
                }
              },
              {
                "elementId": "diagram1",
                "elementType": "diagram",
                "content": {
                  "diagramType": "timeline-flow",
                  "title": "Widget Timeline - Initial Request and Healing Process",
                  "description": "A horizontal timeline diagram showing how WidgetKit requests timeline entries from a provider and renders widgets at specific times. The diagram illustrates a game character's health recovery from 25% to 100% over 3 hours with hourly timeline entries.",
                  "visualDescription": "The diagram appears on a dark background (dark mode documentation). It shows a horizontal flow with multiple components. On the left is a representation of the TimelineProvider component. Arrows flow from the provider to multiple widget rendering states shown as small widget preview cards. Each widget card displays a health bar with increasing fill levels representing 25%, 50%, 75%, and 100% health. Below the widget cards are time markers indicating hourly intervals. The diagram uses Apple's documentation visual styling with rounded rectangles, connecting lines, and arrows.",
                  "nodes": [
                    {
                      "nodeId": "provider",
                      "label": "TimelineProvider",
                      "shape": "rounded-rectangle",
                      "semanticRole": "Source component that generates timeline entries"
                    },
                    {
                      "nodeId": "entry1",
                      "label": "Entry 1 - 25% Health",
                      "shape": "widget-card",
                      "semanticRole": "First timeline entry at current time showing initial health state"
                    },
                    {
                      "nodeId": "entry2",
                      "label": "Entry 2 - 50% Health",
                      "shape": "widget-card",
                      "semanticRole": "Second timeline entry after 1 hour"
                    },
                    {
                      "nodeId": "entry3",
                      "label": "Entry 3 - 75% Health",
                      "shape": "widget-card",
                      "semanticRole": "Third timeline entry after 2 hours"
                    },
                    {
                      "nodeId": "entry4",
                      "label": "Entry 4 - 100% Health",
                      "shape": "widget-card",
                      "semanticRole": "Final timeline entry showing full recovery after 3 hours"
                    }
                  ],
                  "connections": [
                    {
                      "connectionId": "provider-to-widgetkit",
                      "fromNodeId": "provider",
                      "toNodeId": "widgetkit",
                      "label": "Timeline request/response",
                      "arrowHead": "bidirectional",
                      "semanticMeaning": "Provider supplies timeline entries to WidgetKit"
                    },
                    {
                      "connectionId": "time-progression",
                      "fromNodeId": "entry1",
                      "toNodeId": "entry4",
                      "label": "Hourly intervals",
                      "lineStyle": "solid with time markers",
                      "semanticMeaning": "Time progression between entries at 1-hour intervals"
                    }
                  ],
                  "refreshPolicy": {
                    "initial": "atEnd (default)",
                    "final": "never (when fully healed)"
                  },
                  "narrativeWalkthrough": "1. WidgetKit initially requests a timeline from the TimelineProvider. 2. The provider creates four entries: current time (25% health), +1 hour (50%), +2 hours (75%), +3 hours (100%). 3. Refresh policy is set to 'atEnd'. 4. WidgetKit renders the widget at each timeline entry date. 5. After the final entry (100% health), WidgetKit requests a new timeline. 6. Since character is fully healed, provider responds with single entry and 'never' refresh policy. 7. WidgetKit won't request another timeline until app explicitly calls WidgetCenter."
                }
              },
              {
                "elementId": "predictable-para4",
                "elementType": "paragraph",
                "content": {
                  "text": "When WidgetKit initially requests the timeline, the provider creates one with four entries. The first entry represents the current time, followed by three entries at hourly intervals. With the refresh policy set to the default atEnd, WidgetKit requests a new timeline after the last date in the timeline's entries. When each date in the timeline arrives, WidgetKit invokes the widget's content closure and displays the result. After the last timeline entry passes, WidgetKit repeats the process by asking the provider for a new timeline. Because the character's health has reached 100 percent, the provider responds with a single entry for the current time and a refresh policy set to never. With this setting, WidgetKit doesn't ask for another timeline until the app uses WidgetCenter to tell WidgetKit to request a new timeline.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "atEnd", "type": "refresh-policy"},
                    {"text": "never", "type": "refresh-policy"},
                    {"text": "WidgetCenter", "type": "class"}
                  ]
                }
              },
              {
                "elementId": "predictable-para5",
                "elementType": "paragraph",
                "content": {
                  "text": "In addition to the atEnd and never refresh policies, a provider can specify a different date altogether if the timeline might change before or after reaching the end of the entries. For example, if a dragon will appear in 2 hours to challenge the character to a battle, the provider sets the reload policy to after(_:), passing a date 2 hours in the future. The following diagram shows how WidgetKit, after rendering the widget at the 2-hour mark, requests a new one.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "atEnd", "type": "refresh-policy"},
                    {"text": "never", "type": "refresh-policy"},
                    {"text": "after(_:)", "type": "refresh-policy-method"}
                  ]
                }
              },
              {
                "elementId": "diagram2",
                "elementType": "diagram",
                "content": {
                  "diagramType": "timeline-flow",
                  "title": "Widget Timeline - Dragon Battle Interruption with after(_:) Policy",
                  "description": "A timeline diagram showing how an external event (dragon battle) triggers a timeline reload before the original timeline ends using the after(_:) refresh policy.",
                  "visualDescription": "Similar visual style to first diagram with dark background. Shows the timeline being interrupted at the 2-hour mark when a dragon battle is anticipated. The diagram illustrates branching from the original timeline to a new timeline with updated entries reflecting battle damage and extended recovery time.",
                  "nodes": [
                    {
                      "nodeId": "original-timeline",
                      "label": "Original Timeline",
                      "shape": "container",
                      "semanticRole": "The initial timeline before the dragon event"
                    },
                    {
                      "nodeId": "dragon-event",
                      "label": "Dragon Battle at 2-hour mark",
                      "shape": "event-marker",
                      "semanticRole": "External event that triggers timeline reload"
                    },
                    {
                      "nodeId": "new-timeline",
                      "label": "New Timeline (2 entries)",
                      "shape": "container",
                      "semanticRole": "Updated timeline after dragon battle with current time and +2 hours"
                    }
                  ],
                  "connections": [
                    {
                      "connectionId": "original-to-dragon",
                      "fromNodeId": "original-timeline",
                      "toNodeId": "dragon-event",
                      "label": "after(_:) at 2 hours",
                      "semanticMeaning": "Timeline reload triggered at specified future time"
                    },
                    {
                      "connectionId": "dragon-to-new",
                      "fromNodeId": "dragon-event",
                      "toNodeId": "new-timeline",
                      "label": "New timeline request",
                      "semanticMeaning": "WidgetKit requests fresh timeline after event"
                    }
                  ],
                  "refreshPolicy": {
                    "triggerPolicy": "after(_:) with date 2 hours in future",
                    "newTimelinePolicy": "atEnd"
                  },
                  "narrativeWalkthrough": "1. Provider knows a dragon will appear in 2 hours. 2. Sets reload policy to after(_:) with date 2 hours in future. 3. At 2-hour mark, WidgetKit renders current widget state. 4. WidgetKit requests new timeline at the after(_:) date. 5. Due to dragon battle, character needs 2 more hours to heal. 6. New timeline has two entries: current time (damaged) and +2 hours (recovered). 7. New timeline uses atEnd refresh policy (no more known events)."
                }
              },
              {
                "elementId": "predictable-para6",
                "elementType": "paragraph",
                "content": {
                  "text": "Due to the battle with the dragon, the character's healing will take 2 additional hours to reach 100 percent. The new timeline consists of two entries, one for the current time, and a second entry 2 hours in the future. The timeline specifies atEnd for the refresh policy, indicating there are no more known events that might alter the timeline.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "atEnd", "type": "refresh-policy"}
                  ]
                }
              },
              {
                "elementId": "predictable-para7",
                "elementType": "paragraph",
                "content": {
                  "text": "When the 2 hours have passed, and the character's health is at 100 percent, WidgetKit asks the provider for a new timeline. Because the character's health has recovered, the provider generates the same final timeline as the first diagram above. When the user plays the game and the character's health level changes, the app uses WidgetCenter to have WidgetKit refresh the timeline and update the widget.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "WidgetCenter", "type": "class"}
                  ]
                }
              },
              {
                "elementId": "predictable-para8",
                "elementType": "paragraph",
                "content": {
                  "text": "In addition to specifying a date before the end of the timeline, the provider can specify a date after the end of the timeline. This is useful when you know that the widget's state won't change until a later time. For example, a stock market widget could create a timeline at the close of the market on Friday with an after(_:) refresh policy specifying the time the market opens on Monday. Because the stock market is closed over the weekend, there is no need to update the widget until the market opens.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "after(_:)", "type": "refresh-policy-method"}
                  ]
                }
              },
              {
                "elementId": "predictable-important",
                "elementType": "annotation",
                "annotationType": "important",
                "content": {
                  "label": "Important",
                  "text": "Plan ahead if your widget makes requests to a server when it reloads and uses after(_:) with a specific date in timeline entries. WidgetKit tries to respect the date you specify, which may cause a significant increase in server load when multiple devices reload your widget at around the same time.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "after(_:)", "type": "refresh-policy-method"}
                  ]
                }
              }
            ]
          },
          {
            "sectionId": "inform-widgetkit-when-timeline-changes",
            "sectionTitle": "Inform WidgetKit when a timeline changes",
            "elements": [
              {
                "elementId": "inform-heading",
                "elementType": "heading",
                "level": 2,
                "content": {
                  "text": "Inform WidgetKit when a timeline changes",
                  "verbatim": true
                }
              },
              {
                "elementId": "inform-para1",
                "elementType": "paragraph",
                "content": {
                  "text": "Your app can tell WidgetKit to request a new timeline when something affects a widget's current timeline. In the game widget example above, if the app receives a push notification indicating a teammate has given the character a healing potion, the app can tell WidgetKit to reload the timeline and update the widget's content.",
                  "verbatim": true
                }
              },
              {
                "elementId": "inform-para2",
                "elementType": "paragraph",
                "content": {
                  "text": "To reload a specific type of widget, your app uses WidgetCenter, as shown here:",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "WidgetCenter", "type": "class"}
                  ]
                }
              },
              {
                "elementId": "code-example-1",
                "elementType": "code",
                "content": {
                  "language": "Swift",
                  "code": "WidgetCenter.shared.reloadTimelines(ofKind: \"com.mygame.character-detail\")",
                  "verbatim": true,
                  "lineCount": 1,
                  "syntaxHighlighting": {
                    "identifiers": ["WidgetCenter", "shared", "reloadTimelines", "ofKind"],
                    "stringLiterals": ["\"com.mygame.character-detail\""]
                  },
                  "explanation": "Calls the reloadTimelines(ofKind:) method on the shared WidgetCenter instance to reload all widgets matching the specified kind identifier."
                }
              },
              {
                "elementId": "inform-para3",
                "elementType": "paragraph",
                "content": {
                  "text": "The kind parameter contains the same string as the value used to create the widget's WidgetConfiguration.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "kind", "type": "parameter"},
                    {"text": "WidgetConfiguration", "type": "struct"}
                  ]
                }
              },
              {
                "elementId": "inform-para4",
                "elementType": "paragraph",
                "content": {
                  "text": "If your widgets have user-configurable properties, avoid unnecessary reloads by using WidgetCenter to verify that a widget with the appropriate settings exists. For example, when the game receives a push notification about a character receiving a healing potion, it verifies that a widget is showing that character before reloading the timeline.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "WidgetCenter", "type": "class"}
                  ]
                }
              },
              {
                "elementId": "inform-para5",
                "elementType": "paragraph",
                "content": {
                  "text": "In the following code, the app calls getCurrentConfigurations(_:) to retrieve the list of user-configured widgets. It then iterates through the resulting WidgetInfo objects to find one with an intent configured with the character that received the healing potion. If it finds one, the app calls reloadTimelines(ofKind:) for that widget's kind.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "getCurrentConfigurations(_:)", "type": "method"},
                    {"text": "WidgetInfo", "type": "struct"},
                    {"text": "reloadTimelines(ofKind:)", "type": "method"}
                  ]
                }
              },
              {
                "elementId": "code-example-2",
                "elementType": "code",
                "content": {
                  "language": "Swift",
                  "code": "WidgetCenter.shared.getCurrentConfigurations { result in\n    guard case .success(let widgets) = result else { return }\n\n    // Iterate over the WidgetInfo elements to find one that matches\n    // the character from the push notification.\n    if let widget = widgets.first(\n        where: { widget in\n            let intent = widget.configuration as? SelectCharacterIntent\n            return intent?.character == characterThatReceivedHealingPotion\n        }\n    ) {\n        WidgetCenter.shared.reloadTimelines(ofKind: widget.kind)\n    }\n}",
                  "verbatim": true,
                  "lineCount": 14,
                  "syntaxHighlighting": {
                    "keywords": ["guard", "case", "let", "else", "return", "if", "where", "as?"],
                    "identifiers": ["WidgetCenter", "shared", "getCurrentConfigurations", "result", "success", "widgets", "widget", "first", "intent", "configuration", "SelectCharacterIntent", "character", "characterThatReceivedHealingPotion", "reloadTimelines", "ofKind", "kind"],
                    "comments": [
                      "// Iterate over the WidgetInfo elements to find one that matches",
                      "// the character from the push notification."
                    ]
                  },
                  "lineByLineBreakdown": [
                    {"line": 1, "content": "WidgetCenter.shared.getCurrentConfigurations { result in", "description": "Call getCurrentConfigurations with trailing closure receiving Result"},
                    {"line": 2, "content": "    guard case .success(let widgets) = result else { return }", "description": "Extract widgets array from success case, return early on failure"},
                    {"line": 3, "content": "", "description": "Empty line"},
                    {"line": 4, "content": "    // Iterate over the WidgetInfo elements to find one that matches", "description": "Comment explaining iteration purpose"},
                    {"line": 5, "content": "    // the character from the push notification.", "description": "Comment continuation"},
                    {"line": 6, "content": "    if let widget = widgets.first(", "description": "Find first widget matching predicate"},
                    {"line": 7, "content": "        where: { widget in", "description": "Closure parameter for where predicate"},
                    {"line": 8, "content": "            let intent = widget.configuration as? SelectCharacterIntent", "description": "Attempt to cast configuration to SelectCharacterIntent"},
                    {"line": 9, "content": "            return intent?.character == characterThatReceivedHealingPotion", "description": "Check if intent's character matches the one that received potion"},
                    {"line": 10, "content": "        }", "description": "Close where closure"},
                    {"line": 11, "content": "    ) {", "description": "Close if let condition"},
                    {"line": 12, "content": "        WidgetCenter.shared.reloadTimelines(ofKind: widget.kind)", "description": "Reload timelines for matching widget kind"},
                    {"line": 13, "content": "    }", "description": "Close if block"},
                    {"line": 14, "content": "}", "description": "Close trailing closure"}
                  ],
                  "explanation": "This code retrieves all configured widgets, searches for one whose configuration matches a specific character, and only reloads that specific widget's timeline if found. This prevents unnecessary reloads for widgets showing different characters."
                }
              },
              {
                "elementId": "inform-para6",
                "elementType": "paragraph",
                "content": {
                  "text": "If your app uses WidgetBundle to support multiple widgets, you can use WidgetCenter to reload the timelines for all your widgets. For example, if your widgets require the user to sign in to an account but they have signed out, you can reload all the widgets by calling:",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "WidgetBundle", "type": "protocol"},
                    {"text": "WidgetCenter", "type": "class"}
                  ]
                }
              },
              {
                "elementId": "code-example-3",
                "elementType": "code",
                "content": {
                  "language": "Swift",
                  "code": "WidgetCenter.shared.reloadAllTimelines()",
                  "verbatim": true,
                  "lineCount": 1,
                  "syntaxHighlighting": {
                    "identifiers": ["WidgetCenter", "shared", "reloadAllTimelines"]
                  },
                  "explanation": "Reloads timelines for all widgets in the app's WidgetBundle."
                }
              }
            ]
          },
          {
            "sectionId": "update-relevance-information",
            "sectionTitle": "Update relevance information",
            "elements": [
              {
                "elementId": "relevance-heading",
                "elementType": "heading",
                "level": 2,
                "content": {
                  "text": "Update relevance information",
                  "verbatim": true
                }
              },
              {
                "elementId": "relevance-para1",
                "elementType": "paragraph",
                "content": {
                  "text": "On iPhone and iPad, people place widgets in Smart Stacks and rely on the system to show them the most relevant widget at the right time. On Apple Watch, widgets automatically appear in the Smart Stack. To help the system determine when a widget in a Smart Stack is most relevant, and to offer Widget Suggestions, provide the system with hints about your widget's relevance. While this is an optional step, providing relevance clues gives your widget additional visibility. In your timeline provider, implement the relevance() callback and make sure to keep relevance information up-to-date. For more information, refer to Increasing the visibility of widgets in Smart Stacks.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "relevance()", "type": "callback-method"}
                  ],
                  "links": [
                    {
                      "text": "Increasing the visibility of widgets in Smart Stacks",
                      "type": "internal-documentation-link"
                    }
                  ]
                }
              }
            ]
          },
          {
            "sectionId": "display-dynamic-dates",
            "sectionTitle": "Display dynamic dates",
            "elements": [
              {
                "elementId": "dynamic-heading",
                "elementType": "heading",
                "level": 2,
                "content": {
                  "text": "Display dynamic dates",
                  "verbatim": true
                }
              },
              {
                "elementId": "dynamic-para1",
                "elementType": "paragraph",
                "content": {
                  "text": "Even though your widget doesn't run continually, it can display time-based information that WidgetKit updates live. For example, it might display a countdown timer that continues to count down even if your widget extension isn't running. For more information, refer to Displaying dynamic dates in widgets.",
                  "verbatim": true,
                  "links": [
                    {
                      "text": "Displaying dynamic dates in widgets",
                      "type": "internal-documentation-link"
                    }
                  ]
                }
              }
            ]
          },
          {
            "sectionId": "load-data-from-server",
            "sectionTitle": "Load data from your server before updating the timeline",
            "elements": [
              {
                "elementId": "load-heading",
                "elementType": "heading",
                "level": 2,
                "content": {
                  "text": "Load data from your server before updating the timeline",
                  "verbatim": true
                }
              },
              {
                "elementId": "load-para1",
                "elementType": "paragraph",
                "content": {
                  "text": "You may need to load new data from your server before reloading a timeline. To do this, use the system's URL loading system and a URLSession. To learn more, refer to Making network requests in a widget extension.",
                  "verbatim": true,
                  "codeReferences": [
                    {"text": "URLSession", "type": "class"}
                  ],
                  "links": [
                    {
                      "text": "Making network requests in a widget extension",
                      "type": "internal-documentation-link"
                    }
                  ]
                }
              }
            ]
          },
          {
            "sectionId": "see-also",
            "sectionTitle": "See Also",
            "elements": [
              {
                "elementId": "seealso-heading",
                "elementType": "heading",
                "level": 2,
                "content": {
                  "text": "See Also",
                  "verbatim": true
                }
              },
              {
                "elementId": "seealso-subheading",
                "elementType": "heading",
                "level": 3,
                "content": {
                  "text": "Timeline updates",
                  "verbatim": true
                }
              },
              {
                "elementId": "seealso-list",
                "elementType": "list",
                "listType": "definition",
                "content": {
                  "items": [
                    {
                      "term": "protocol TimelineProvider",
                      "definition": "A type that advises WidgetKit when to update a widget's display.",
                      "prefix": "Pr",
                      "symbolType": "protocol",
                      "verbatim": true
                    },
                    {
                      "term": "protocol AppIntentTimelineProvider",
                      "definition": "A type that advises WidgetKit when to update a user-configurable widget's display.",
                      "prefix": "Pr",
                      "symbolType": "protocol",
                      "verbatim": true
                    },
                    {
                      "term": "protocol IntentTimelineProvider",
                      "definition": "A type that advises WidgetKit when to update a user-configurable widget's display.",
                      "prefix": "Pr",
                      "symbolType": "protocol",
                      "verbatim": true
                    },
                    {
                      "term": "struct TimelineProviderContext",
                      "definition": "An object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery.",
                      "prefix": "S",
                      "symbolType": "struct",
                      "verbatim": true
                    },
                    {
                      "term": "protocol TimelineEntry",
                      "definition": "A type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget's content.",
                      "prefix": "Pr",
                      "symbolType": "protocol",
                      "verbatim": true
                    },
                    {
                      "term": "struct Timeline",
                      "definition": "An object that specifies a date for WidgetKit to update a widget's view.",
                      "prefix": "S",
                      "symbolType": "struct",
                      "verbatim": true
                    },
                    {
                      "term": "class WidgetCenter",
                      "definition": "An object that contains a list of user-configured widgets and is used for reloading widget timelines.",
                      "prefix": "C",
                      "symbolType": "class",
                      "verbatim": true
                    }
                  ]
                }
              }
            ]
          }
        ],
        "readingOrder": [
          "page-title",
          "page-subtitle",
          "overview-heading",
          "overview-para1",
          "overview-list1",
          "overview-para2",
          "budget-heading",
          "budget-para1",
          "budget-para2",
          "budget-list1",
          "budget-para3",
          "budget-para4",
          "budget-note",
          "budget-para5",
          "budget-list2",
          "budget-para6",
          "budget-para7",
          "budget-list3",
          "budget-para8",
          "predictable-heading",
          "predictable-para1",
          "predictable-para2",
          "predictable-para3",
          "diagram1",
          "predictable-para4",
          "predictable-para5",
          "diagram2",
          "predictable-para6",
          "predictable-para7",
          "predictable-para8",
          "predictable-important",
          "inform-heading",
          "inform-para1",
          "inform-para2",
          "code-example-1",
          "inform-para3",
          "inform-para4",
          "inform-para5",
          "code-example-2",
          "inform-para6",
          "code-example-3",
          "relevance-heading",
          "relevance-para1",
          "dynamic-heading",
          "dynamic-para1",
          "load-heading",
          "load-para1",
          "seealso-heading",
          "seealso-subheading",
          "seealso-list"
        ],
        "pageSummary": "This page documents how to keep iOS/macOS widgets up to date using WidgetKit. It covers the budget system for widget reloads (40-70 refreshes per day), creating timelines with TimelineProvider for predictable events, using refresh policies (atEnd, never, after(_:)), informing WidgetKit of timeline changes via WidgetCenter, updating relevance for Smart Stacks, displaying dynamic dates, and loading server data before timeline updates."
      }
    ],
    "semanticStructure": {
      "documentSections": [
        {
          "sectionId": "overview",
          "title": "Overview",
          "summary": "Introduces widget update mechanisms: timelines for predictable events, system reload triggers, and WidgetKit push notifications. Emphasizes that widgets are rendered in a separate process and the extension is not continually active."
        },
        {
          "sectionId": "plan-reloads-within-budget",
          "title": "Plan reloads within a budget",
          "summary": "Explains the widget reload budget system, factors affecting budget allocation (visibility, last reload time, app activity), typical refresh rates (40-70 per day, every 15-60 minutes), cases exempt from budget (app foreground, audio/navigation sessions, animations, locale/accessibility changes), and system-initiated reloads."
        },
        {
          "sectionId": "generate-timeline-for-predictable-events",
          "title": "Generate a timeline for predictable events",
          "summary": "Details how to create timelines using TimelineProvider and TimelineEntry. Uses an extended game health widget example showing character health recovery. Covers refresh policies: atEnd (default), never, and after(_:). Includes two diagrams and warns about server load with synchronized reloads."
        },
        {
          "sectionId": "inform-widgetkit-when-timeline-changes",
          "title": "Inform WidgetKit when a timeline changes",
          "summary": "Covers using WidgetCenter to reload timelines programmatically. Includes three code examples: reloadTimelines(ofKind:) for specific widgets, getCurrentConfigurations(_:) to check before reloading, and reloadAllTimelines() for all widgets."
        },
        {
          "sectionId": "update-relevance-information",
          "title": "Update relevance information",
          "summary": "Explains Smart Stack relevance on iPhone, iPad, and Apple Watch. Recommends implementing relevance() callback in timeline provider for additional visibility and Widget Suggestions."
        },
        {
          "sectionId": "display-dynamic-dates",
          "title": "Display dynamic dates",
          "summary": "Mentions that widgets can display live time-based information like countdown timers without the extension running."
        },
        {
          "sectionId": "load-data-from-server",
          "title": "Load data from your server before updating the timeline",
          "summary": "Points to URLSession and network requests documentation for loading remote data before timeline reloads."
        },
        {
          "sectionId": "see-also",
          "title": "See Also - Timeline updates",
          "summary": "API reference listing: TimelineProvider, AppIntentTimelineProvider, IntentTimelineProvider, TimelineProviderContext, TimelineEntry, Timeline, and WidgetCenter with brief descriptions."
        }
      ],
      "documentFlow": "The document progresses from a high-level overview of widget update mechanisms, through detailed explanation of the budget system and its constraints, to practical implementation of timeline providers with a comprehensive game widget example featuring two diagrams. It then covers programmatic timeline reloading with three code examples, Smart Stack relevance, dynamic dates, and server data loading, concluding with an API reference."
    },
    "extractedKnowledge": {
      "keyTerms": [
        {"term": "Timeline", "definition": "An array of TimelineEntry objects that specifies when to update a widget's view", "occurrences": 25},
        {"term": "TimelineProvider", "definition": "A protocol that advises WidgetKit when to update a widget's display", "occurrences": 8},
        {"term": "TimelineEntry", "definition": "A type that specifies the date to display a widget and optionally indicates relevance", "occurrences": 6},
        {"term": "WidgetCenter", "definition": "An object that contains user-configured widgets and is used for reloading widget timelines", "occurrences": 12},
        {"term": "Budget", "definition": "System-managed allocation of widget reloads distributed over 24 hours, tuned to user's daily usage pattern", "occurrences": 8},
        {"term": "Refresh Policy", "definition": "Tells WidgetKit when to request a new timeline; options are atEnd, never, or after(_:)", "occurrences": 6},
        {"term": "atEnd", "definition": "Default refresh policy; requests new timeline after the last entry in the current timeline", "occurrences": 4},
        {"term": "never", "definition": "Refresh policy that prevents automatic timeline requests until explicitly triggered via WidgetCenter", "occurrences": 3},
        {"term": "after(_:)", "definition": "Refresh policy specifying a specific date for the next timeline request, can be before or after timeline end", "occurrences": 5},
        {"term": "Smart Stack", "definition": "A stack of widgets where the system shows the most relevant widget at the right time based on relevance hints", "occurrences": 3},
        {"term": "AppIntentTimelineProvider", "definition": "A protocol for user-configurable widgets using App Intents", "occurrences": 2},
        {"term": "IntentTimelineProvider", "definition": "A protocol for user-configurable widgets using SiriKit Intents (legacy)", "occurrences": 2},
        {"term": "TimelineProviderContext", "definition": "Contains details about widget rendering including size and whether in widget gallery", "occurrences": 1},
        {"term": "WidgetInfo", "definition": "Object returned by getCurrentConfigurations containing widget kind and configuration", "occurrences": 1},
        {"term": "WidgetBundle", "definition": "Protocol for apps supporting multiple widget types", "occurrences": 1},
        {"term": "WidgetConfiguration", "definition": "Configuration object for defining a widget's kind and properties", "occurrences": 1}
      ],
      "keyFindings": [
        "Widget extensions are not continually active; WidgetKit renders views in a separate process",
        "Daily budget for frequently viewed widgets is typically 40-70 refreshes (reloads every 15-60 minutes)",
        "Budget applies to a 24-hour period tuned to user's daily usage pattern, not necessarily resetting at midnight",
        "System takes a few days to learn user's behavior; widgets may receive more reloads during this learning period",
        "Timeline entries should be at least about 5 minutes apart",
        "WidgetKit may coalesce reloads across multiple widgets, affecting exact reload times",
        "Reloads don't count against budget when: app in foreground, active audio/navigation session, app intent performed, animation performed, locale changes, or Dynamic Type/Accessibility settings change",
        "StandBy mode refreshes at system-defined rate that doesn't count against budget",
        "WidgetKit may reduce reload frequency for widgets on rarely-visited Home Screen pages",
        "Location Services widgets reload after significant location changes",
        "Using after(_:) with specific dates may cause server load spikes when many devices reload simultaneously",
        "Smart Stack relevance can be influenced by implementing the relevance() callback",
        "Dynamic time-based content (like countdown timers) can update live without reloading the widget"
      ],
      "technicalSpecifications": {
        "minimumTimelineInterval": "approximately 5 minutes between timeline entries",
        "typicalDailyBudget": "40-70 refreshes for frequently viewed widgets",
        "refreshIntervalRange": "15-60 minutes (varies based on many factors)",
        "budgetPeriod": "24 hours (tuned to user's daily usage pattern)",
        "refreshPolicies": {
          "atEnd": "Request new timeline after last entry (default)",
          "never": "Never request automatically; wait for WidgetCenter trigger",
          "after(_:)": "Request at specific date (can be before or after timeline end)"
        }
      },
      "bestPractices": [
        "Generate timelines for as many future dates as possible to minimize reload requests",
        "Keep timeline entry intervals as large as possible for the content being displayed",
        "Create timeline entries at least 5 minutes apart (WidgetKit minimum)",
        "Use getCurrentConfigurations(_:) to verify widget settings before triggering reloads to avoid unnecessary budget consumption",
        "Set refresh policy to 'never' when widget state is stable and won't change without external trigger",
        "Plan server requests to avoid synchronized load when using after(_:) with specific dates across many devices",
        "Implement relevance() callback to increase widget visibility in Smart Stacks",
        "Use URLSession for network requests when loading data before timeline updates",
        "Don't request timeline reloads for system appearance or locale changes; system handles these automatically"
      ],
      "codeExamples": [
        {
          "id": "reload-specific-widget",
          "title": "Reload a specific widget type",
          "language": "Swift",
          "code": "WidgetCenter.shared.reloadTimelines(ofKind: \"com.mygame.character-detail\")",
          "useCase": "When external data changes affect a specific widget type",
          "explanation": "The kind parameter must match the string used in the widget's WidgetConfiguration"
        },
        {
          "id": "check-configurations-before-reload",
          "title": "Check widget configurations before reloading",
          "language": "Swift",
          "code": "WidgetCenter.shared.getCurrentConfigurations { result in\n    guard case .success(let widgets) = result else { return }\n\n    // Iterate over the WidgetInfo elements to find one that matches\n    // the character from the push notification.\n    if let widget = widgets.first(\n        where: { widget in\n            let intent = widget.configuration as? SelectCharacterIntent\n            return intent?.character == characterThatReceivedHealingPotion\n        }\n    ) {\n        WidgetCenter.shared.reloadTimelines(ofKind: widget.kind)\n    }\n}",
          "useCase": "When you have configurable widgets and want to avoid wasting budget on irrelevant reloads",
          "explanation": "Retrieves all configured widgets, checks if any match criteria, and only reloads matching widgets"
        },
        {
          "id": "reload-all-widgets",
          "title": "Reload all widgets",
          "language": "Swift",
          "code": "WidgetCenter.shared.reloadAllTimelines()",
          "useCase": "When a global state change (like user sign-out) affects all widgets",
          "explanation": "Reloads timelines for all widgets in the app's WidgetBundle"
        }
      ],
      "relatedDocumentation": [
        {
          "title": "Updating widgets with WidgetKit push notifications",
          "type": "article",
          "relationship": "Complementary feature for widget updates beyond timelines"
        },
        {
          "title": "Accessing location information in widgets",
          "type": "article",
          "relationship": "Related capability that affects widget reload behavior"
        },
        {
          "title": "Making network requests in a widget extension",
          "type": "article",
          "relationship": "Implementation guide for loading server data before timeline updates"
        },
        {
          "title": "Displaying dynamic dates in widgets",
          "type": "article",
          "relationship": "Alternative to timeline-based updates for live time displays"
        },
        {
          "title": "Increasing the visibility of widgets in Smart Stacks",
          "type": "article",
          "relationship": "Guide for Smart Stack relevance optimization"
        },
        {
          "title": "Previewing widgets and Live Activities",
          "type": "article",
          "relationship": "Development and debugging tool for widgets"
        }
      ],
      "apiReference": {
        "timelineUpdates": [
          {
            "name": "TimelineProvider",
            "symbolType": "protocol",
            "prefix": "Pr",
            "description": "A type that advises WidgetKit when to update a widget's display."
          },
          {
            "name": "AppIntentTimelineProvider",
            "symbolType": "protocol",
            "prefix": "Pr",
            "description": "A type that advises WidgetKit when to update a user-configurable widget's display."
          },
          {
            "name": "IntentTimelineProvider",
            "symbolType": "protocol",
            "prefix": "Pr",
            "description": "A type that advises WidgetKit when to update a user-configurable widget's display."
          },
          {
            "name": "TimelineProviderContext",
            "symbolType": "struct",
            "prefix": "S",
            "description": "An object that contains details about how a widget is rendered, including its size and whether it appears in the widget gallery."
          },
          {
            "name": "TimelineEntry",
            "symbolType": "protocol",
            "prefix": "Pr",
            "description": "A type that specifies the date to display a widget, and, optionally, indicates the current relevance of the widget's content."
          },
          {
            "name": "Timeline",
            "symbolType": "struct",
            "prefix": "S",
            "description": "An object that specifies a date for WidgetKit to update a widget's view."
          },
          {
            "name": "WidgetCenter",
            "symbolType": "class",
            "prefix": "C",
            "description": "An object that contains a list of user-configured widgets and is used for reloading widget timelines."
          }
        ],
        "pushNotificationUpdates": [
          {
            "name": "Updating widgets with WidgetKit push notifications",
            "type": "article"
          },
          {
            "name": "WidgetPushHandler",
            "symbolType": "protocol",
            "prefix": "Pr"
          },
          {
            "name": "WidgetPushInfo",
            "symbolType": "struct",
            "prefix": "S"
          }
        ],
        "capabilities": [
          {
            "name": "Accessing location information in widgets",
            "type": "article"
          },
          {
            "name": "Making network requests in a widget extension",
            "type": "article"
          }
        ],
        "debugging": [
          {
            "name": "Previewing widgets and Live Activities",
            "type": "article"
          },
          {
            "name": "Preview macros",
            "type": "topic"
          }
        ]
      }
    },
    "visualElements": {
      "pageAppearance": {
        "colorScheme": "Dark mode (as captured in PDF)",
        "backgroundColor": "Dark gray/near-black (#1c1c1e or similar)",
        "textColor": {
          "primary": "White/light gray for body text",
          "secondary": "Medium gray for less prominent text",
          "links": "Blue (#0066CC or similar) for hyperlinks"
        },
        "codeBlockAppearance": {
          "backgroundColor": "Slightly lighter dark gray than page background",
          "textColor": "Light gray/white with syntax highlighting",
          "fontFamily": "Monospace (SF Mono or similar)"
        },
        "annotationStyles": {
          "note": {
            "backgroundColor": "Dark gray with subtle border",
            "labelColor": "Gray",
            "labelText": "Note"
          },
          "important": {
            "backgroundColor": "Dark gray with amber/orange accent",
            "labelColor": "Amber/orange",
            "labelText": "Important"
          }
        }
      },
      "layoutStructure": {
        "type": "Three-column documentation layout",
        "leftSidebar": {
          "width": "~250px",
          "content": "Navigation tree with collapsible sections",
          "backgroundColor": "Same as page background"
        },
        "mainContent": {
          "width": "Flexible, centered",
          "maxWidth": "~800px for readability",
          "content": "Article content with headings, paragraphs, code, diagrams"
        },
        "rightSidebar": {
          "width": "~200px",
          "content": "Tools, Topics & Technologies, Resources, Support, Account, Programs, Events links"
        }
      },
      "typographySystem": {
        "h1": "Large bold sans-serif for page title",
        "h2": "Medium bold sans-serif for section headings",
        "h3": "Smaller bold sans-serif for subsection headings",
        "body": "Regular sans-serif (SF Pro or similar)",
        "code": "Monospace (SF Mono or similar)",
        "symbolPrefixes": "Monospace badges (Pr, S, C) indicating protocol, struct, class"
      },
      "diagrams": [
        {
          "diagramId": "diagram1",
          "title": "Widget Timeline - Initial Request and Healing Process",
          "type": "Timeline/sequence flow diagram",
          "visualStyle": "Apple documentation style with rounded rectangles and connecting arrows",
          "colorScheme": "Dark mode with light-colored elements"
        },
        {
          "diagramId": "diagram2",
          "title": "Widget Timeline - Dragon Battle Interruption",
          "type": "Timeline/sequence flow diagram showing interrupted timeline",
          "visualStyle": "Apple documentation style with rounded rectangles and connecting arrows",
          "colorScheme": "Dark mode with light-colored elements"
        }
      ]
    },
    "documentTypos": [
      {
        "location": "overview-list1, first item",
        "original": "Create a timeline that updates your widget for for regular, predictable events.",
        "issue": "Double 'for for' should be single 'for'"
      },
      {
        "location": "budget-para6",
        "original": "that doesn't count against the its budget",
        "issue": "'the its' should be just 'its'"
      },
      {
        "location": "predictable-para3",
        "original": "When the health level is less then 100 percent",
        "issue": "'less then' should be 'less than'"
      }
    ]
  }
}
